#!/usr/bin/env python3
"""
Generate Rust phf::Map tables for MA-L (/24), MA-M (/28), MA-S (/36).
- Fetches IEEE CSVs over HTTPS only.
- Cleans invisible/non-printable Unicode from organization names.
- Emits only static PHF maps (no helpers).

Usage:
  python3 gen_oui_rust_phf.py > ../src/oui_map.rs
"""

import argparse
import csv
import io
import re
import sys
import unicodedata
import urllib.request
from typing import Dict, Iterable, List, Tuple

# Official IEEE CSV endpoints
SRC_MAL = "https://standards-oui.ieee.org/oui/oui.csv"       # /24
SRC_MAM = "https://standards-oui.ieee.org/oui28/mam.csv"     # /28
SRC_MAS = "https://standards-oui.ieee.org/oui36/oui36.csv"   # /36

ASSIGN_RE = re.compile(r"(?i)^[^/]+?(?:/(\d{2}))?")  # capture optional /NN

def fetch_bytes_http(url: str) -> bytes:
    import time
    from urllib.error import HTTPError

    for attempt in range(10):
        try:
            with urllib.request.urlopen(url) as r:
                return r.read()
        except HTTPError as e:
            if e.code == 418 and attempt < 9:
                print(f"Got HTTP 418 (I'm a teapot) for {url}, attempt {attempt + 1}/10. Retrying...", file=sys.stderr)
                time.sleep(5)
                continue
            else:
                raise

    # This should never be reached due to the exception handling above
    raise RuntimeError("Unexpected code path in fetch_bytes_http")

def clean_str(s: str) -> str:
    """Strip and remove invisible/non-printable Unicode; normalize NFC."""
    s = (s or "").strip()
    cleaned = "".join(
        ch for ch in s
        if unicodedata.category(ch)[0] != "C"  # drop Cc, Cf, Cs, Co, Cn
    )
    return unicodedata.normalize("NFC", cleaned)

def rust_escape(s: str) -> str:
    out = []
    for ch in s:
        o = ord(ch)
        if ch == "\\":
            out.append("\\\\")
        elif ch == '"':
            out.append('\\"')
        elif ch == "\n":
            out.append("\\n")
        elif ch == "\r":
            out.append("\\r")
        elif ch == "\t":
            out.append("\\t")
        elif o < 0x20:
            out.append(f"\\x{o:02X}")
        else:
            out.append(ch)
    return "".join(out)

def parse_registry(csv_bytes: bytes, expected_registry: str) -> List[Tuple[int, int, str]]:
    """Return [(bits, prefix_value_int, org_name_cleaned), ...] for a given registry."""
    rdr = csv.DictReader(io.StringIO(csv_bytes.decode("utf-8", errors="replace")))
    need = {"Registry", "Assignment", "Organization Name"}
    if not need.issubset(set(h or "" for h in (rdr.fieldnames or []))):
        raise SystemExit(
            f"CSV missing required headers; found {rdr.fieldnames}. "
            "Need: Registry, Assignment, Organization Name"
        )

    out: List[Tuple[int, int, str]] = []
    for row in rdr:
        reg = (row.get("Registry") or "").strip().upper()
        if reg != expected_registry.upper():
            continue

        assignment_raw = (row.get("Assignment") or "").strip()
        org = clean_str(row.get("Organization Name") or "")
        if not assignment_raw or not org:
            continue

        # Extract optional '/NN'
        m = ASSIGN_RE.match(assignment_raw)
        cidr = int(m.group(1)) if (m and m.group(1)) else None

        # Keep only hex digits from the assignment value
        hexpart = "".join(c for c in assignment_raw if c in "0123456789ABCDEFabcdef").upper()
        if not hexpart:
            continue

        # Derive prefix length if missing
        default_bits = {"MA-L": 24, "MA-M": 28, "MA-S": 36}[expected_registry.upper()]
        bits = cidr or (4 * len(hexpart))
        if bits not in (24, 28, 36):
            bits = default_bits

        needed_nibbles = bits // 4
        if len(hexpart) < needed_nibbles:
            continue
        hexn = hexpart[:needed_nibbles]

        try:
            val = int(hexn, 16)
        except ValueError:
            continue

        out.append((bits, val, org))
    return out

def dedupe_keep_first(rows: Iterable[Tuple[int, int, str]]) -> Dict[Tuple[int, int], str]:
    out: Dict[Tuple[int, int], str] = {}
    for bits, val, org in rows:
        out.setdefault((bits, val), org)
    return out

def render_rust(phf24: List[Tuple[int, str]],
                phf28: List[Tuple[int, str]],
                phf36: List[Tuple[int, str]]) -> str:
    lines: List[str] = []
    lines.append("// @generated by gen_oui_rust_phf.py â€” DO NOT EDIT.\n")
    lines.append("use phf::phf_map;\n\n")

    lines.append("/// MA-L (/24) map: key = top 24 bits as u32 (first 3 octets).\n")
    lines.append("pub static OUI24: phf::Map<u32, &'static str> = phf_map! {\n")
    for val, org in phf24:
        lines.append(f'    0x{val:06X}u32 => "{rust_escape(org)}",\n')
    lines.append("};\n\n")

    lines.append("/// MA-M (/28) map: key = top 28 bits as u32 (7 hex nibbles).\n")
    lines.append("pub static OUI28: phf::Map<u32, &'static str> = phf_map! {\n")
    for val, org in phf28:
        lines.append(f'    0x{val:07X}u32 => "{rust_escape(org)}",\n')
    lines.append("};\n\n")

    lines.append("/// MA-S (/36) map: key = top 36 bits as u64 (9 hex nibbles).\n")
    lines.append("pub static OUI36: phf::Map<u64, &'static str> = phf_map! {\n")
    for val, org in phf36:
        lines.append(f'    0x{val:09X}u64 => "{rust_escape(org)}",\n')
    lines.append("};\n")

    # Helper functions
    lines.append("""\
/// Lookup by raw bytes; tries /36, then /28, then /24.
pub fn lookup_vendor_bytes(mac: [u8; 6]) -> Option<&'static str> {
    let v36: u64 = ((mac[0] as u64) << 40)
        | ((mac[1] as u64) << 32)
        | ((mac[2] as u64) << 24)
        | ((mac[3] as u64) << 16)
        | ((mac[4] as u64) << 8);
    if let Some(v) = OUI36.get(&(v36 >> 4)) {
        return Some(v);
    } // top 36 bits

    let v28: u32 = ((mac[0] as u32) << 20)
        | ((mac[1] as u32) << 12)
        | ((mac[2] as u32) << 4)
        | ((mac[3] as u32) >> 4);
    if let Some(v) = OUI28.get(&v28) {
        return Some(v);
    }

    let v24: u32 = ((mac[0] as u32) << 16) | ((mac[1] as u32) << 8) | (mac[2] as u32);
    OUI24.get(&v24).copied()
}
""")

    return "".join(lines)

def main():
    ap = argparse.ArgumentParser(description="Generate Rust phf maps for MA-L(/24), MA-M(/28), MA-S(/36)")
    ap.add_argument("--out", default="-", help="Output .rs file (default: stdout)")
    args = ap.parse_args()

    rows: List[Tuple[int, int, str]] = []
    for url, reg in ((SRC_MAL, "MA-L"), (SRC_MAM, "MA-M"), (SRC_MAS, "MA-S")):
        rows.extend(parse_registry(fetch_bytes_http(url), reg))

    unique = dedupe_keep_first(rows)
    mal = sorted(((v, org) for (b, v), org in unique.items() if b == 24), key=lambda x: x[0])
    mam = sorted(((v, org) for (b, v), org in unique.items() if b == 28), key=lambda x: x[0])
    mas = sorted(((v, org) for (b, v), org in unique.items() if b == 36), key=lambda x: x[0])

    rs = render_rust(mal, mam, mas)
    if args.out == "-" or not args.out:
        sys.stdout.write(rs)
    else:
        with open(args.out, "w", encoding="utf-8", newline="\n") as f:
            f.write(rs)

if __name__ == "__main__":
    main()
